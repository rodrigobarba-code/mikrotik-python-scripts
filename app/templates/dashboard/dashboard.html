{% extends 'base.html' %}

{% block title %} Dashboard {% endblock %}

{% block head %}
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/base/styles.css') }}">
{% endblock %}

{% block scripts %}
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const chartData = {{ dashboard_data|tojson }};
            const publicIpsData = {{ public_ips_data|tojson }};
            const totalIpsData = {{ total_ips_data|tojson }};
            const ctxPrivate = document.getElementById('myChart').getContext('2d');
            const ctxPublic = document.getElementById('publicIpChart').getContext('2d');
            let currentPrivateChart;
            let currentPublicChart;

            function createGradient(ctx, colorStart, colorEnd) {
                const width = ctx.canvas.width;   // Ancho del canvas
                const height = ctx.canvas.height; // Alto del canvas

                const gradient = ctx.createLinearGradient(0, 0, width, height);
                gradient.addColorStop(0, colorStart);
                gradient.addColorStop(1, colorEnd);
                return gradient;
            }

            // Función para actualizar el gráfico con gradientes
            function createChart(ctx, assignedQuantity, availableQuantity, isPublic = false) {
                const assignedGradient = createGradient(
                    ctx,
                    isPublic ? '#FF4500' : '#FF0000',
                    isPublic ? '#FFAA00' : '#FFD700'
                );
                const availableGradient = createGradient(
                    ctx,
                    isPublic ? '#1E90FF' : '#00008B',
                    isPublic ? '#87CEEB' : '#00BFFF'
                );

                return new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Assigned', 'Available'],
                        datasets: [{
                            label: isPublic ? 'Public IPs' : 'Private IPs',
                            data: [assignedQuantity, availableQuantity],
                            backgroundColor: [assignedGradient, availableGradient],
                            borderWidth: 0, // Sin borde
                            hoverBorderColor: 'rgba(255, 255, 255, 0.5)',
                            hoverBorderWidth: 2,
                            borderRadius: [30, 30],
                            spacing: -30
                        }]
                    },
                    options: {
                        responsive: true,
                        cutout: '70%',
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    font: {
                                        size: 14
                                    },
                                    usePointStyle: true,
                                    pointStyle: 'rectRounded'
                                }
                            }
                        }
                    }
                });
            }

            // Función para inicializar o actualizar el gráfico privado
            function updatePrivateChart(site, segment) {
                const data = chartData[site];
                const assigned = data.assigned.find(s => Object.keys(s)[0] === segment);
                const available = data.available.find(s => Object.keys(s)[0] === segment);

                const assignedQuantity = assigned ? Object.values(assigned)[0].quantity : 0;
                const availableQuantity = available ? Object.values(available)[0].quantity : 0;

                if (currentPrivateChart) currentPrivateChart.destroy();
                currentPrivateChart = createChart(ctxPrivate, assignedQuantity, availableQuantity);
            }

            // Función para inicializar o actualizar el gráfico público
            function updatePublicChart(site, segment) {
                const data = publicIpsData[site];
                const assigned = data.assigned.find(s => Object.keys(s)[0] === segment);
                const available = data.available.find(s => Object.keys(s)[0] === segment);

                const assignedQuantity = assigned ? Object.values(assigned)[0].quantity : 0;
                const availableQuantity = available ? Object.values(available)[0].quantity : 0;

                if (currentPublicChart) currentPublicChart.destroy();
                currentPublicChart = createChart(ctxPublic, assignedQuantity, availableQuantity, true);
            }

            // Función para actualizar los filtros y gráficos
            function updateFilters() {
                const siteSelect = document.getElementById('siteFilter');
                const segmentSelect = document.getElementById('segmentFilter');
                const selectedSite = siteSelect.value;

                segmentSelect.innerHTML = '';
                if (chartData[selectedSite]) {
                    chartData[selectedSite].assigned.forEach(segment => {
                        const segmentKey = Object.keys(segment)[0];
                        const option = document.createElement('option');
                        option.value = segmentKey;
                        option.textContent = segmentKey;
                        segmentSelect.appendChild(option);
                    });
                }

                updatePrivateChart(selectedSite, segmentSelect.value);
            }

            function updatePublicFilters() {
                const siteSelect = document.getElementById('site-select');
                const segmentSelect = document.getElementById('segment-select');
                const selectedSite = siteSelect.value;

                segmentSelect.innerHTML = '';
                if (publicIpsData[selectedSite]) {
                    publicIpsData[selectedSite].assigned.forEach(segment => {
                        const segmentKey = Object.keys(segment)[0];
                        const option = document.createElement('option');
                        option.value = segmentKey;
                        option.textContent = segmentKey;
                        segmentSelect.appendChild(option);
                    });
                }

                updatePublicChart(selectedSite, segmentSelect.value);
            }

            // Eventos para actualizar gráficos
            document.getElementById('siteFilter').addEventListener('change', updateFilters);
            document.getElementById('segmentFilter').addEventListener('change', function () {
                const siteSelect = document.getElementById('siteFilter');
                const segmentSelect = document.getElementById('segmentFilter');
                updatePrivateChart(siteSelect.value, segmentSelect.value);
            });

            document.getElementById('site-select').addEventListener('change', updatePublicFilters);
            document.getElementById('segment-select').addEventListener('change', function () {
                const siteSelect = document.getElementById('site-select');
                const segmentSelect = document.getElementById('segment-select');
                updatePublicChart(siteSelect.value, segmentSelect.value);
            });

            // Inicializar los filtros al cargar la página
            updateFilters();
            updatePublicFilters();
        });
    </script>

{% endblock %}

{% block content %}
    <!-- Dashboard Jumbotron -->
    <section class="dashboard-jumbotron">
        <div class="container-fluid py-5 overview-container">
            <h1 class="display-5 fw-bold">Overview</h1>
        </div>
    </section>
    <!-- Dashboard Jumbotron -->

    <!-- Overview Card-Top -->
    <div class="container card-top-container">
        <div class="row">
            <div class="col-lg-12 col-md-12 col-sm-12 card-container">
                <div class="d-flex justify-content-evenly">
                    <div class="card card-top">
                        <div class="card-body">
                            <h5 class="card-title">Total IPs</h5>
                            <span class="badge rounded-pill">
                                {{ total_ips_data.total }}
                            </span>
                        </div>
                    </div>
                    <div class="card card-top hover-card">
                        <div class="card-body">
                            <h5 class="card-title">Anomalies found</h5>
                            <span class="badge rounded-pill">
                                {{ total_ips_data.count_arps }}
                            </span>
                            <a href="{{ url_for('router_scan.scan') }}" class="btn-hover">View Details</a>
                        </div>
                    </div>
                    <div class="card card-top">
                        <div class="card-body">
                            <h5 class="card-title">Blacklist/Authorized found</h5>
                            <span class="badge rounded-pill">
                                {{ total_ips_data.count_ip_groups }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Overview Card-Top -->

    <!-- Dashboard Content -->
    <div class="container-fluid dashboard-content-container">
        <div class="container">
            <div class="row">
                <!-- Panel 1 -->
                <div class="col-lg-4 col-md-6 col-sm-12 dashboard-content">
                    <div class="card p-3">
                        <h5 class="card-title">Assigned and Available Private IP</h5>

                        <!-- Selector for site -->
                        <label for="siteFilter" class="form-label">Select a site:</label>
                        <select id="siteFilter" class="form-select mb-3">
                            {% for site in sites %}
                                <option value="{{ site[1] }}">{{ site[1] }}</option>
                            {% endfor %}
                        </select>

                        <!-- Segment selector -->
                        <label for="segmentFilter" class="form-label">Select a segment:</label>
                        <select id="segmentFilter" class="form-select mb-3">
                        </select>
                        <!-- Canvas for the chart -->
                        <canvas id="myChart"></canvas>
                    </div>
                </div>
                <!-- Panel 2 -->
                <div class="col-lg-4 col-md-6 col-sm-12 dashboard-content">
                    <div class="card p-3">
                        <h5 class="card-title">Assigned and Available Public IP</h5>

                        <!-- Selector for choose the site -->
                        <label for="site-select" class="form-label">Select a site:</label>
                        <select id="site-select" class="form-select mb-3">
                            {% for site in sites %}
                                <option value="{{ site[1] }}">{{ site[1] }}</option>
                            {% endfor %}
                        </select>

                        <!-- Segment selector -->
                        <label for="segment-select" class="form-label">Select a segment:</label>
                        <select id="segment-select" class="form-select mb-3">
                        </select>
                        <!-- Canvas for the chart -->
                        <canvas id="publicIpChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Dashboard Content -->
{% endblock %}
